#!/usr/bin/perl

use strict;
use warnings;

use DateTime::Format::Natural ();
use Term::ReadLine ();

use constant LANG_DEFAULT => 'en';

my $format;
my $lang                = LANG_DEFAULT;
my $prefer_future       = 0;
my @supported_languages = qw(en);
my $trace               = 0;
my %valid_languages     = map { $_ => 1 } @supported_languages;

parse_switches() if @ARGV;

sub parse_switches 
{
    use Getopt::Long qw(:config no_auto_abbrev no_ignore_case);

    my %opts;
    GetOptions(\%opts, qw(f|format=s
                          h|help
                          l|lang=s
                          p|prefer_future
                          s|supported
                          t|trace
                          V|version)) or usage();

    usage()     if $opts{h};
    version()   if $opts{V};
    supported() if $opts{s};

    $lang            = $opts{l} || LANG_DEFAULT;
    $format        ||= $opts{f};
    $prefer_future ||= $opts{p};
    $trace           = $opts{t};
}

sub usage 
{
    print <<USAGE;
Usage: $0 [switches]
  -f, --format           format of numeric dates
  -h, --help             this help screen
  -l, --lang             language code
  -p, --prefer_future    use futuristic dates (when possible)
  -s, --supported        list of supported languages
  -t, --trace            print trace after processing
  -V, --version          print version
USAGE
    exit;
}

sub version 
{
    print "  DateTime::Format::Natural $DateTime::Format::Natural::VERSION\n";
    exit;
}

sub supported 
{
    print "$_\n" foreach @supported_languages;
    exit;
}

unless ($valid_languages{$lang}) {
    warn "Language [$lang] isn't supported, switching to default [", LANG_DEFAULT, "]\n";
    $lang = LANG_DEFAULT;
}

my $term = Term::ReadLine->new('dateparse');
my $prompt = 'dateparse> ';

while (defined(my $input = $term->readline($prompt))) {
    $term->addhistory($input) if $input =~ /\S/;
    last if $input =~ /^(?:quit|exit)$/;
    
    if ($input =~ /^(?:\?|help)$/i) {
        print <<EOT;

Commands
 ?, help		this help screen
 exit, quit	  	leave dateparse
 everything else        datetime string

EOT
        next;
    }

    my $parse = DateTime::Format::Natural->new(
                lang          => $lang,
                format        => $format,
                prefer_future => $prefer_future,
    );
    my @dt = $parse->parse_datetime_duration(string => $input);

    if ($parse->success) {
        foreach my $dt (@dt) {
            printf("%02d.%02d.%4d %02d:%02d:%02d\n", $dt->day, $dt->month, $dt->year, $dt->hour, $dt->min, $dt->sec);
        }
    } 
    else {
        warn $parse->error, "\n";
    }

    if ($trace) {
        print $parse->trace, "\n";
    }
}

=head1 NAME

dateparse - frontend to DateTime::Format::Natural

=head1 SYNOPSIS

 Usage: dateparse [switches]
   -f, --format           format of numeric dates
   -h, --help             this help screen
   -l, --lang             language code
   -p, --prefer_future    use futuristic dates (when possible)
   -s, --supported        list of supported languages
   -t, --trace            print trace after processing
   -V, --version          print version

=head1 AUTHOR

Steven Schubiger <schubiger@cpan.org>

=head1 LICENSE

This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>

=cut
